---
layout: post
title: "操作系统之nachos实践lab4"
description: "个人学习OS笔记（1）nachos"
categories: [OS]
tags: [OS]
redirect_from:
  - /2019/04/17/
---

* Karmdown table of content
{:toc .toc}

# Exercise 1  调研

出处：[Linux内核中各种同步机制](https://www.cnblogs.com/liuwei0773/articles/9506748.html)

Linux中同步机制较为完善，为了实现其同步机制Linux中有多种模块。如：原子操作，自旋锁，读写自旋锁，信号量，读写信号量，互斥量，完成变量，大内核锁，顺序锁，禁止抢占，顺序和屏蔽等。

## 原子操作

原子操作是由编译器来保证的，保证一个线程对数据的操作不会被其他线程打断。 

## 自旋锁

原子操作只能用于临界区只有一个变量的情况，实际应用中，临界区的情况要复杂的多。对于复杂的临界区，Linux 内核提供了多种方法，自旋锁就是其一。

自旋锁的特点就是当一个线程获取了锁之后，其他试图获取这个锁的线程一直在循环等待获取这个锁，直至锁重新可用。由于线程一直在循环获取这个锁，所以会造成 CPU 处理时间的浪费，因此最好将自旋锁用于很快能处理完的临界区。

## 读写自旋锁

读写自旋锁除了和普通自选锁一样有自旋特性外，还有以下特点，读锁之间是共享的，即一个线程持有了读锁之后，其他线程也可以以读的方式持有这个锁。

写锁之间是互斥的，即一个县城持有了写锁之后，其他线程不能以读或者写的方式持有这个锁。

读写锁之间是互斥的，即一个县城持有了读锁之后，其他线程不能以写的方式持有这个锁。

## 信号量
  
信号量也是一种锁，和自旋锁不同的是，线程获取不到信号量的时候，不会像自旋锁一样循环区试图获取锁，而是进入睡眠，直至有信号量释放出来时，才会唤醒睡眠的线程，进入临界区执行。

由于使用信号量时，线程会睡眠，所以等待的过程不会占用 CPU 时间。所以信号量适用于等待时间较长的临界区。 

信号量消耗 CPU 时间的地方在于使线程睡眠和唤醒线程。 

如果（使线程睡眠 + 唤醒线程）的 CPU 时间 > 线程自旋等待 CPU 时间，那么可以考虑使用自旋锁。 

信号量睡眠一般会进入 TASK_INTERRUPTIBLE 状态，因为另一个无法被信号唤醒。 

## 读写信号量
  
为了提高内核并发执行能力，内核提供了读入者信号量和写入者信号量。它们的概念和实现机制类似于读写自旋锁。

## 互斥量

mutex 使用的场景比二值信号量严格，如下：

mutex 计数值只能为 1，也就是说最多允许一个线程访问临界区。

必须在同一个上下文问加锁和解锁。

不能递归的上锁和解锁。

持有 mutex 时，进程不能退出。

mutex 不能在中断或者下半部使用，也就是 mutex 只能在进程上下文中使用。

mutex 只能通过官方 API 管理，不能自己写代码操作它 :)

## 完成变量
  
完成变量名为 completion。完成变量类似于信号量，当线程完成任务出了临界区之后，使用完成变量唤醒等待线程（更像 condition）。 



# Exercise 2  源代码阅读

## code/threads/synch.h(synch.cc)

synch.h中声明了三个类，Semaphore，Lock和Condition。

Semaphore主要函数有初始化函数Semaphore(char* debugName, int initialValue)和p(), v()。主要变量有int  value, List *queue。queue中存储的是V操作失败的进程队列。p操作中value--，V操作中value ++。

Lock中主要函数为初始化函数Lock()和Acquire(), Release()。但是这些函数都没有很好的实现，这一类尚处于不可使用状态。

Condition类中主要方法有构造函数Condition()和Wait(), Signal(), Broadcast()。但是这些函数同样没有实现，也处于不可使用状态。

## code/threads/synchlist.h(synchlist.cc)

实现了同步条件下的List的最基本操作。然而实现过程中需要使用到Condition类和Lock类。这两个类都是未完整实现的类。故Synchlist也是一个不可使用的类。

# Exercise 3  实现锁和条件变量

## 锁的实现

由于信号量已经实现，我们可以利用信号量方便快捷的实现锁，因此在类Lock中，我们首先需要声明Semaphore类型的成员变量lock存储一个二元信号量。在V操作中我们需要判断当前锁的拥有着是不是当前线程，故需要声明Thread类型的成员变量owner存储拥有此锁的进程。同时在Lock的构造函数对上述变量分别进行赋值。

析构函数较为简单，只需要delete信号量lock即可。	

acquire函数的实现也较为简单，只需要对信号量进行p操作和对owner的赋值。此外需要注意操作中应当关闭中断，操作结束后恢复中断的原先状态。

release操作中，首先需要判断owner与当前进程是否一致，如果一直则执行V操作，如果不一致则返回错误。同acquire操作一样，应当对中断进行控制。

## 条件锁的实现

Condition中需要维护一个队列用于存放等待当前条件变量中的所有进程，声明为private的List。

wait()函数的实现需要关闭中断，之后释放锁，将当前进程存储到等待队列中并且睡眠此进程。等进程被唤醒时重新申请锁。
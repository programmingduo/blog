---
layout: post
title: "推荐算法"
description: ""
categories: [NLP]
tags: []
redirect_from:
  - /2023/08/17/
---

* Karmdown table of content
{:toc .toc}


# 好的推荐系统

一张巨牛逼的图，一张图就是一个章节。

![smiley](/blog/assets/images/usedInBlogs/RecommendationSystem/0.jpg)

# 利用用户行为数据

由于推荐系统最重要的一个参与者是用户，因此我们需要对用户进行深入的了解。但是如何去了解用户的兴趣和需求呢？有一种靠谱的解决方案就是用户在注册的时候能够主动告诉我们他们的兴趣，虽然这种方案很有效。但是却面临以下三个缺点：

> 1.自然语言处理技术很难捕获用户用来描述兴趣的自然语言
> 2.用户的兴趣动态变化，注册填写信息是静态的
> 3.用户不知道或很难描述出自己喜欢什么


因此，利用用户行为数据，从用户的行为中推测出用户兴趣的方案就得以凑效。本章将从下面几个点来介绍如何利用用户行为数据进行推荐。

1.用户行为数据简介
2.用户行为分析
3.实验设计和算法评测
4.基于邻域的算法
5.隐语义模型
6.基于图的模型

## 用户行为数据简介

### 用户行为数据存在形式

日志是用户行为数据在网络上存在的最简单记录形式。推荐系统和电子商务网站在运行的过程中会产生大量的原始日志（raw log），并存于文件系统中。原始日志经过汇总可生成描述用户行为的会话日志（session log），其每个会话表示一次用户行为和对应服务。会话日志通常存储于分布式数据仓库中，可以支持离线分析Hadoop Hive和在线分析Google Dremel。会话日志中记录了用户的各种行为，如电子商务网站中的网页浏览、购买、点击、评论和评分等。

raw log需要通过前端埋点进行实现。具体来讲，前端在开发过程中将需要采集事件状态的按钮进行埋点，用户在点击的时候输出到NGINX的log中，在通过flume系统将这部分事件进行筛选、处理，得到会话日志。对于前端和后台而言，这都是很大的工程量。因此，小黑作坊或者小团队很难完成推荐系统的整体开发工作。

### 用户行为数据反馈分类

用户行为数据按照反馈明确性可以划分为：显性反馈行为（explicit feedback）和隐性反馈行为（implicit feedback）。其中显性反馈行为主要包含用户对物品明确喜欢的行为。如用户喜欢或不喜欢某物品。与显性反馈对应的就是隐性反馈，隐性反馈行为指的是用户对物品行为喜好不明确。如网页浏览行为。相比于显性反馈行为数据，隐性反馈行为数据数据量更大。

显示反馈数据和隐式反馈数据对比如下图：


![smiley](/blog/assets/images/usedInBlogs/RecommendationSystem/1.jpg)


此外，按照反馈方向划分，用户行为数据可以分为正反馈和负反馈。正反馈指的是用户的行为倾向于用户喜欢该物品，而负反馈指用户的行为不喜欢该物品。

### 用户行为数据集介绍

用户行为非常重要，但有些在处理数据时，有些信息是可以忽略的，有些是要保留下来。下面这四种形式的数据集是目前比较具有代表性的：

> 无上下文信息的隐性反馈数据集（每条行为记录仅仅包括用户ID和物品ID，如 [Book-Crossing数据集](​www.informatik.uni-freiburg.de/~cziegler/BX/) ）
> 无上下文信息的显性反馈数据集（每条记录包含用户ID、物品ID和对物品评分）
> 有上下文信息的隐性反馈数据集（每条记录包含用户ID、物品ID、行为时间戳，如[Lastfm数据集](​www.dtic.upf.edu/~ocelma/MusicRecommendationDataset/lastfm-1K.html)）
> 有上下文信息的显性反馈数据集（每条记录包含用户ID、物品ID、用户对物品评分和评分行为发生时间戳，如 [Netflix Prize: Home](​netflixprize.com/)）

## 用户行为分析

用户活跃度和物品流行度也出现长尾现象。具体而言，流行度超过100的物品，数量很少。而流行度低于100的物品，数量非常多。

新用户倾向于浏览热门的物品，因为他们对网站不熟悉只能点击人们物品。而老用户逐渐浏览冷门物品。

## 评测指标

推荐系统的评测指标可见第一章的图片。比较实用的有：实验主要采用准确率、召回率来评测推荐算法精度，覆盖率来评测算法发掘长尾的能力，新颖度（这里用物品的平均流行度）来表示推荐算法的新颖程度。

## 协同过滤算法

仅仅基于用户行为数据设计的推荐算法一般都称为协同过滤算法。其中包括 基于领域方法（neighborhood-based）、隐语义模型（latent factor model）、基于图的随机游走算法（random walk on graph） 等。

### 基于领域方法

基于领域方法是业界得到最广泛应用的算法。这种方法主要分为以下两种算法：

基于用户的协同过滤算法：这种算法给用户推荐和用户兴趣相似的其他用户喜欢的物品。
基于物品的协同过滤算法：这种算法给用户推荐和用户之前喜欢物品相似的其他物品。

#### 基于用户的协同过滤算法

基于用户的协同过滤算法（User-based Collaborative Filtering，UserCF）是推荐系统中最古老的算法，该算法在1992年被提出用户邮件过滤系统，1994年被GroupLens用于新闻过滤。直到2000年以后，该算法都是推荐系统中最著名的算法。



基于用户的协同过滤算法主要包括两个步骤:

> 1.找到和目标用户兴趣相似的用户集合
> 2.找到这个集合中用户喜欢的，且目标用户没有听说过的物品推荐给目标用户

步骤1的关键之处就是在计算两个用户的兴趣相似度。这里，协同过滤算法主要利用用户行为的相似度来计算用户兴趣的相似度。

计算相似度基础算法包括：（1）Jaccard similarity（2）Cosine similarity。这里只讲述改进之后的算法。

![smiley](/blog/assets/images/usedInBlogs/RecommendationSystem/2.png)

其中u和v分别表示用户u和用户v，N(u)和N(v)分别表示用户u和v曾经有过正反馈的物品集合

直接求解两两用户相似度的时间复杂度是 O(|User|\*|User|\*|Product|) 。为了减少复杂度，构建从物品到用户的倒排索引，仅计算对同一物品有过操作的用户对的相似度即可。通过这一操作，复杂度降到了O(|Product|\*1/K|User|\*1/K|User|)，其中K为常数，1/k表示对同一物品有交际的用户占总用户的比例。

在得到步骤1的物品之间的相似度后，ItemCF可以通过如下公式计算用户u对物品j的兴趣：

![smiley](/blog/assets/images/usedInBlogs/RecommendationSystem/3.png)

其中S(i,K)包含和物品j最相似的前K个物品的集合，wji是物品j和物品i的兴趣相似度，rui 代表用户u对物品i的兴趣。

#### 基于物品的协同过滤算法

基于物品的协同过滤算法（Item-based Collaborative Filtering，ItemCF）是亚马逊2003年提出的推荐算法，是目前业界应用最多的算法。跟UserCF没有太大区别，只不过将物品和用户的角色互换而已。

基于用户的协同过滤算法（UserCF）和物品的协同过滤算法(ItemCF)中也只有一个重要参数K,即每次选出最相似物品的数量。在MovieLens数据集中，K=10左右会获得比较高的准确率和召回率。因此K对于获得高的推荐系统精度比较重要。

Karypis发现如果将ItemCF的相似度矩阵按最大值归一化，可以提高推荐的准确率。因此，对计算的物品相似度矩阵w进行归一化可得：

![smiley](/blog/assets/images/usedInBlogs/RecommendationSystem/4.png)

归一化不仅可增加推荐准确率，还可提升推荐的覆盖率和多样性。

#### UserCF和ItemCF的综合比较

> 提出时间：UserCF相对较早，1992就已在电子邮件的推荐系统Tapestry得到应用，1994年被GroupLens用于新闻推荐。而ItemCF出道较晚，于2003年亚马逊的Greg等学者公布。
> 算法原理：UserCF给用户推荐那些和他有共同兴趣爱好的用户喜欢的物品，而ItemCF给用户推荐那些和他之前喜欢的物品类似的物品。
> 推荐特点：UserCF推荐更社会化，折射出用户所在的小型群体中物品的热门程度。而ItemCF的推荐更加个性化，着重维护用户的历史兴趣。
> 推荐场景：UserCF需要维护用户相似性表，适合用户更新不频繁的场景。因此UserCF适用于微博、新闻、微内容等推荐。ItemCF需要维护物品相似性表，适合物品更新不频率的场景。因此ItemCF适用于图书、电子商务和电影网站等推荐。

![smiley](/blog/assets/images/usedInBlogs/RecommendationSystem/4.jpg)